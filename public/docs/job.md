# 失业了

准确来说, 是公司黄了.

在老板的一顿骚操作下失去了项目渠道也失去了投资方, 团队直接就地解散.去年毕业进了这家创业公司, 今年就倒闭, 史诗级职业生涯开局.

9 月 28 号开了离职证明, 正好在双节前解散, 过节也没买到回老家的车票, 就这么在北京一个人孤独的熬了 9 天.

## tobecontinue

## 面试提词

### 自我介绍

姓名, 年龄, 去年刚毕业, 喜欢做些高科技的东西, 搞搞开源, 翻译.

### 提问环节

1. 规模, 工作强度.
2. 个人发展, 待遇. 沐曦期望问区间
3. 面试次数

### 技术面小抄

#### 开发习惯

- 代码风格, 细节, 单一职责, tdd, 错误处理, 命名规范, 开闭原则, 可维护性

#### 系统相关

- 协程同线程的比较: 协程是协作式多任务, 典型的线程是内核级抢占. 协程提供并发性而非并行性. 协程的好处是在协程之间的切换不需要涉及任何系统调用或任何阻塞调用, 没互斥锁和信号量, 不需要操作系统支持.
- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间；而线程是共享进程中的数据、地址空间的。

#### rust 相关

- rust-gdb 断点调试.

- Option 是 std 的 Nullable 枚举类型, 内容为 Some(T) 具体值 T 和 None. 用于处理空指针可能返回空值.

- Box 是智能指针. 它用于在堆上分配内存并存储数据. 基本上是用于创建动态分配的数据结构, 用来避免数据在栈上分配.

- dyn 用于标识实现了某个 trait 的具体类型, 它告诉编译器, 某个值的类型实现了指定的 trait.这通常用于多态和动态派发.

- `Option<Box<dyn SomeTrait>>` 表示一个 Option 包含一个指向实现了 SomeTrait 的某具体类型的 Box, 同时处理可能为空的、动态分派的情况.

- Dynamic dispatch 是指运行时选择多态的实现来调用的过程.

- async 函数, 编译器会将其转化为一个返回 Future 的函数.
  当你调用一个 async 函数, 它会返回一个 Future, 在 Future 上调用 .await, 将控制权还给事件循环.

- Future 是一个表示异步操作的抽象 trait, 一个尚未完成的异步任务, 它可能在未来的某个时间点产生一个值或错误, 包含了异步操作的逻辑.

> Future 的核心方法是 poll, 定义在 Future trait 中.
> poll 方法接受一个 Context 对象作为参数, 它提供了执行异步计算所需的环境和资源.
> poll 返回一个 Poll 枚举值, Pending: 表示计算尚未完成, 需要继续轮询. Ready(result): 表示计算已经完成, 产生了一个值或一个错误..

- `.await` 操作符来等待一个 Future 的完成, 而不会阻塞整个线程. 执行权将被释放回到事件循环, 允许其他任务执行, 直到 Future 准备好之后, 控制权再返回到 .await 之后的代码, 具体由 runtime 负责控制事件循环, 轮询未完成的 Future, 等待它们完成.

- 异步任务可以并发执行, 而不会阻塞主线程.

#### 数据结构

- 链表存指针

1. Array 连续内存空间, 同类型:

   - 插入：在指定位置插入元素通常需要 O(n) 时间, 因为需要将后续元素向后移动.
   - 删除：删除元素通常需要 O(n) 时间, 因为需要将后续元素向前移动.
   - 修改：根据索引直接修改元素需要 O(1) 时间.
   - 查找：根据索引随机访问内存查找元素需要 O(1) 时间, 其他 O(logn) 到 O(n).

2. Linked List, 不连续内存空间:

   - 插入：在指定位置插入元素通常需要 O(1) 时间, 因为只需要调整节点的链接.
   - 删除：删除元素通常需要 O(1) 时间, 因为只需要调整节点的链接.
   - 修改：根据节点引用直接修改元素需要 O(1) 时间.
   - 查找：查找元素需要 O(n) 时间, 因为必须遍历链表来找到目标元素.

3. Stack:

   - 入栈：入栈操作通常需要 O(1) 时间.
   - 出栈：出栈操作通常需要 O(1) 时间.

4. Queue:

   - 入队：入队操作通常需要 O(1) 时间.
   - 出队：出队操作通常需要 O(1) 时间.

5. Hash Table:

   - 插入：插入元素通常需要平均 O(1) 时间, 但最坏情况下可能需要 O(n) 时间.
   - 删除：删除元素通常需要平均 O(1) 时间, 但最坏情况下可能需要 O(n) 时间.
   - 修改：根据键直接修改元素需要平均 O(1) 时间.
   - 查找：根据键查找元素需要平均 O(1) 时间.
     > 因为哈希函数的功能就是完成键到哈希值的映射, 映射到的哈希值就是一个数字, 被用来当作数组的下标, 这个元素就是存储在数组的这个下标内. 散列表用的其实是数组随机存取的特性. 数组随机存取的复杂度就是 O(1), 所以散列表的查找效率就是 O(1).

6. Binary Search Tree:
   插入：插入元素的时间复杂度取决于树的平衡性, 平均情况为 O(log n), 最坏情况为 O(n).
   删除：删除元素的时间复杂度取决于树的平衡性, 平均情况为 O(log n), 最坏情况为 O(n).
   修改：根据键修改元素的时间复杂度与查找类似, 平均情况为 O(log n).
   查找：根据键查找元素的时间复杂度与树的平衡性有关, 平均情况为 O(log n), 最坏情况为 O(n).
